from pathlib import Path
import csv
import subprocess
import sys
import traceback

from SCons.Script import Import  # type: ignore

Import("env")


def _read_fs_offset(partitions_csv: Path) -> int:
    with partitions_csv.open(newline="") as f:
        reader = csv.reader(f)
        for row in reader:
            if not row or row[0].strip().startswith("#"):
                continue
            # Name, Type, SubType, Offset, Size
            name = row[0].strip()
            if name.lower() in {"spiffs", "littlefs", "fat", "ffat"}:
                offset_str = row[3].strip().lower()
                return int(offset_str, 16) if offset_str.startswith("0x") else int(offset_str)
    raise RuntimeError("Filesystem partition not found in partitions CSV")


def _get_esptool_py() -> list[str]:
    # Use PlatformIO-provided esptool.py
    pkg_dir = env.PioPlatform().get_package_dir("tool-esptoolpy")
    if not pkg_dir:
        raise RuntimeError("tool-esptoolpy package not found")
    esptool = Path(pkg_dir) / "esptool.py"
    pythonexe = Path(env.subst("$PYTHONEXE"))
    return [str(pythonexe), str(esptool)]


def _merge_bins(target, source, env):
    try:
        build_dir = Path(env.subst("$BUILD_DIR"))
        progname = env.subst("$PROGNAME")  # usually 'firmware'

        bootloader_bin = build_dir / "bootloader.bin"
        partitions_bin = build_dir / "partitions.bin"
        app_bin = build_dir / f"{progname}.bin"
        # LittleFS image name generated by PlatformIO
        fs_bin = build_dir / "littlefs.bin"

    # Fallbacks in case names differ
        if not app_bin.exists():
            cand = list(build_dir.glob("*.bin"))
            for p in cand:
                if p.name not in {"bootloader.bin", "partitions.bin"} and "littlefs" not in p.name:
                    app_bin = p
                    break

        project_dir = Path(env.subst("$PROJECT_DIR"))
        # Resolve partitions CSV robustly
        partitions_opt = None
        try:
            partitions_opt = env.GetProjectOption("board_build.partitions")
        except Exception:
            pass
        if not partitions_opt:
            try:
                partitions_opt = env.BoardConfig().get("build.partitions")
            except Exception:
                partitions_opt = None
        if not partitions_opt:
            # Fallback to common default
            if (project_dir / "partitions.csv").exists():
                partitions_opt = "partitions.csv"
            elif (project_dir / "partitions_4mb.csv").exists():
                partitions_opt = "partitions_4mb.csv"
            else:
                raise RuntimeError("Cannot resolve partitions CSV path")

        partitions_csv = project_dir / partitions_opt
        print(f"[merge_bins] PROJECT_DIR={project_dir}")
        print(f"[merge_bins] BUILD_DIR={build_dir}")
        print(f"[merge_bins] PARTITIONS_CSV={partitions_csv}")
        fs_offset = _read_fs_offset(partitions_csv)

        # Standard ESP32 offsets
        boot_offset = 0x1000
        part_offset = 0x8000
        app_offset = 0x10000

    # Sanity checks
        missing = [p for p in [bootloader_bin, partitions_bin, app_bin, fs_bin] if not p.exists()]
        if missing:
            # If FS is missing, try to build it automatically
            if fs_bin in missing:
                print("[merge_bins] littlefs.bin missing -> running buildfs target")
                pioexe = Path(env.subst("$PLATFORMIO_CI_SRC")).name if env.subst("$PLATFORMIO_CI_SRC") else ""
                # Use PlatformIO command to build FS for current env
                subprocess.check_call([
                    sys.executable,
                    "-m",
                    "platformio",
                    "run",
                    "-e",
                    env.subst("$PIOENV"),
                    "-t",
                    "buildfs",
                ])
            # Recompute missing after trying buildfs
            missing = [p for p in [bootloader_bin, partitions_bin, app_bin, fs_bin] if not p.exists()]
            if missing:
                print("[merge_bins] Missing binaries:", ", ".join(str(m) for m in missing))
                return

        out_bin = build_dir / "combined.bin"

        cmd = (
            _get_esptool_py()
            + [
                "--chip",
                "esp32",
                "merge_bin",
                "-o",
                str(out_bin),
                hex(boot_offset),
                str(bootloader_bin),
                hex(part_offset),
                str(partitions_bin),
                hex(app_offset),
                str(app_bin),
                hex(fs_offset),
                str(fs_bin),
            ]
        )

        print("[merge_bins] CMD:", " ".join(cmd))
        print("[merge_bins] Merging to:", out_bin)
        subprocess.check_call(cmd)
        print("[merge_bins] Combined image created:", out_bin)
    except Exception:
        print("[merge_bins] Exception:\n" + traceback.format_exc(), file=sys.stderr)


# Run after firmware binary is built
env.AddPostAction("$BUILD_DIR/${PROGNAME}.bin", _merge_bins)
# Also run after filesystem image is built to handle 'pio run -t buildfs'
env.AddPostAction("$BUILD_DIR/littlefs.bin", _merge_bins)


